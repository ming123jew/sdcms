<?php

namespace app\Controllers\Spider;

use Server\Components\CatCache\CatCacheRpcProxy;
use Server\Components\Event\EventDispatcher;
use Server\Components\TimerTask\Timer;

/**
 * Created by PhpStorm.
 * User: ming123jew
 * Date: 17-09-14
 * Time: am09:51
 */
class Webpage extends Base
{
    protected $get_url_ms_queue_key = 'Home-Webpag-get_url-ms-queue';

    //任务队列
    protected $redis_home_webPage_spider_task_queue_key='redis_home_webPage_spider_task_queue_key';
    //任务队列限制
    protected $redis_home_webPage_spider_task_limt = 3;


    public function initialization($controller_name, $method_name)
    {
        parent::initialization($controller_name, $method_name); // TODO: Change the autogenerated stub
        /** @var 初始化curl信息 */
        $this->header = $this->agent[rand(0, count($this->agent) - 1)];
        $this->referer = empty($referer) ? 'http://weixin.sogou.com/' : $referer;
        $this->host = empty($host) ? 'weixin.sogou.com' : $host;
        /** @var 处理微信图片的防盗链 */
        //$this->antiLeech = 'http://'.$_SERVER['SERVER_NAME'].'/admin.php/tool/wechat-img?url=';
        $this->antiLeech = '';
    }


    //处理页面 url
    public function http_get_url($url='',$match='')
    {


        //抓取的URL
        $url = 'https://www.sanwen8.cn/sanwen/';
        //匹配规则
        $match = [
            'div .alist li',//规则1
            'li h3 a',//规则2
            /*'#/<a .*?>.*?<\/a>/#',*/
        ];

        //生成一个唯一临时key
        $event_type_uuid = create_uuid().'-'.md5($url.time());

        //设置队列限制，只同时进行10个任务
        //获取redis同时链接
        $this->Data['activeCount'] =  yield $this->redis_pool->getRedisPool()->getClientCount();

        if($this->Data['activeCount']>10){
            $this->Data['message'] = '服务器开小差.';
        }else{
            //人数限制
            $saleCount = intval( yield $this->redis_pool->getCoroutine()->lLen($this->get_url_ms_queue_key) );
            print_r('\n正在执行任务数:'.$saleCount.'\n');
            //小于10个则有机会
            if ($saleCount < 10) {
                //压入队列
                yield $this->redis_pool->getCoroutine()->rpush( $this->get_url_ms_queue_key,$event_type_uuid);

                //投递一个任务
                $channel = $this->AMQPChannel;
                $msgBody = json_encode([
                    'url'=> $url,
                    'match'=>$match,
                    'params'=>['EventType'=>$event_type_uuid],
                    'callBackClass'=>\app\Controllers\Spider\AnalyseUrl::class,//必须带/路径，pool才能找到class
                    'action'=>'getUrlList']);
                $this->AMQPMessage->setBody($msgBody);
                //$msg = new AMQPMessage($this->AMQPMessage, ['content_type' => 'text/plain', 'delivery_mode' => 2]); //生成消息  //, ['content_type' => 'text/plain', 'delivery_mode' => 2]
                $channel->basic_publish($this->AMQPMessage,$this->AMQPMessage_exchange); //推送消息到某个交换机

                //等待任务结束 接收数据 设置永久等待，直到返回结果
                $this->Data['message'] = yield EventDispatcher::getInstance()
                    ->addOnceCoroutine($event_type_uuid)
                    ->setTimeout(999999999)
                    ->noException(['status'=>0,'message'=>'timeout!']);

                if($this->Data['message']['status']==1){
                    //任务成功处理
                    //将获取到的链接投入spider_content表

                    //设置链接处理状态

                    //进行投递任务【开始获取内容】

                }else{
                    //任务失败处理
                }
                yield $this->redis_pool->getCoroutine()->lPop($this->get_url_ms_queue_key);
                //退出队列

            }else{
                $this->Data['message'] = '已进行10个任务，超出限制.';
            }

        }

        parent::httpOutputTis($this->Data['message']);
    }

    /**
     * 清除获取get_url函数涉及到的限制队列
     * @return \Generator
     */
    public function http_clean_get_url_ms_queue(){
        yield $this->redis_pool->getCoroutine()->del($this->get_url_ms_queue_key);
        //$this->Data[$this->get_url_ms_queue_key] = yield $this->redis_pool->getCoroutine()->keys('userlock*');
        //foreach ($this->Data['userlocks'] as $key=>$value){
        //    yield $this->redis_pool->getCoroutine()->del($value);
        //}
        parent::httpOutputTis('ok');
    }

    //处理内容
    public function http_get_content(){
        //抓取数组 [ ['title'=>'','url'=>''],['title'=>'','url'=>''],['title'=>'','url'=>''] ]
        $params = $this->http_input->postGet('params');
        file_put_contents('/home/wwwroot/sdcms/aaa',var_export($params,TRUE));
        print_r("post");


        //抓取的URL
        $url = 'https://www.sanwen8.cn/sanwen/';
        //匹配规则
        $match = [
            'div .alist li',//规则1
            'li h3 a',//规则2
            /*'#/<a .*?>.*?<\/a>/#',*/
        ];

        //投递一个任务
        $channel = $this->AMQPChannel;
        $context = $this;
        $end_params = end($params);

        foreach ($params as $key=>$value){

            \swoole_timer_after(3000, function ()use($value,$match,$end_params,$channel,$context) {
                echo "after 3000ms.\n";
                if($value==$end_params){
                    $msgBody = json_encode([
                        'url' => $value['url'],
                        'match'=>$match,
                        'params'=>['channel'=>$channel],
                        'callBackClass'=>\app\Controllers\Spider\AnalyseContent::class,
                        'action'=>'getContent']);
                }else{
                    $msgBody = json_encode([
                        'url' => $value['url'],
                        'match'=>$match,
                        'params'=>[],
                        'callBackClass'=>\app\Controllers\Spider\AnalyseContent::class,
                        'action'=>'getContent']);
                }

                $context->AMQPMessage->setBody($msgBody);
                $channel->basic_publish($context->AMQPMessage,$context->AMQPMessage_exchange); //推送消息到某个交换机
            });
        }
        //print_r($channel);
        parent::httpOutputTis('ok');
    }

    function curl_string ($url,$user_agent,$proxy_ip="",$proxy_port=""){
        $ip= self::_ip();
        $ch = curl_init();
        curl_setopt ($ch, CURLOPT_PROXYAUTH, CURLAUTH_BASIC); //代理认证模式
        curl_setopt ($ch, CURLOPT_PROXY, $proxy_ip); //代理服务器地址
        curl_setopt($ch, CURLOPT_PROXYPORT, $proxy_port); //代理服务器端口
        //curl_setopt($ch, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);
        curl_setopt ($ch, CURLOPT_URL, $url);
        curl_setopt ($ch, CURLOPT_USERAGENT, $user_agent);
        //curl_setopt ($ch, CURLOPT_COOKIEJAR, "d:\cookies.txt");
        curl_setopt ($ch, CURLOPT_HEADER, 1);
        curl_setopt ($ch, CURLOPT_HTTPHEADER, array('CLIENT-IP:'.$ip, 'X-FORWARDED-FOR:'.$ip));  //此处可以改为任意假IP
        curl_setopt ($ch, CURLOPT_RETURNTRANSFER, 1);
        curl_setopt ($ch, CURLOPT_FOLLOWLOCATION, 1);
        curl_setopt ($ch, CURLOPT_TIMEOUT, 120);

        $result = curl_exec ($ch);
        curl_close($ch);
        return $result;
    }
    private function _http($url)
    {
        $ch = curl_init($url);
        $options = [
            CURLOPT_USERAGENT => self::_agent(),
            CURLOPT_REFERER => $this->referer,
        ];
        curl_setopt_array($ch, $options);
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
        curl_setopt($ch, CURLOPT_BINARYTRANSFER, true);
        curl_setopt($ch, CURLOPT_TIMEOUT, 60);
        $output = curl_exec($ch);
        return $output;
    }


    /**
     * 事件处理
     */
    public function http_getEvent()
    {

        $data = yield EventDispatcher::getInstance()->addOnceCoroutine('unlock')->setTimeout(1000)->noException('time over.');
        //这里会等待事件到达，或者超时
        $this->http_output->end($data);
    }

    public function http_sendEvent()
    {
        EventDispatcher::getInstance()->dispatch('unlock', 'hello block');
        $this->http_output->end('ok');
    }

    public function http_test(){
        $this->http_output->end($this->getContext());

    }

}