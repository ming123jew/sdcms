<?php
namespace app;

use PhpAmqpLib\Message\AMQPMessage;
use Server\Asyn\AMQP\AMQP;
use Server\Components\Process\ProcessManager;
use Server\CoreBase\HttpInput;
use Server\CoreBase\Loader;
use Server\SwooleDistributedServer;
use app\Process\MyProcess;
use app\Process\MyAMQPTaskProcess;
/**
 * Created by PhpStorm.
 * User: zhangjincheng
 * Date: 16-9-19
 * Time: 下午2:36
 */
class AppServer extends SwooleDistributedServer
{
    /**
     * 可以在这里自定义Loader，但必须是ILoader接口
     * AppServer constructor.
     */
    public function __construct()
    {
        $this->setLoader(new Loader());
        //通过这个可以精确判断发生异常和错误的位置，也可以了解到SD框架的工作流程。
        $this->setDebugMode();
        parent::__construct();


    }

    /**
     * 开服初始化(支持协程)
     * @return mixed
     */
    public function onOpenServiceInitialization()
    {
        yield parent::onOpenServiceInitialization();
    }

    /**
     * 这里可以进行额外的异步连接池，比如另一组redis/mysql连接
     * @param $workerId
     * @return array
     */
    public function initAsynPools($workerId)
    {
        parent::initAsynPools($workerId);
        if($workerId==0)
        {

            $amqp = new AMQP('localhost',5672,'guest','guest');
            $channel = $amqp->channel();
            //声明一个队里，durable消息持久化
            $channel->queue_declare('msgs', false, true, false, false);
            //交换机,直连交换机（direct）, 主题交换机（topic）, （头交换机）headers和 扇型交换机（fanout）
            $channel->exchange_declare('router', 'direct', false, true, false);
            //我们已经创建了一个扇型交换机和一个队列。现在我们需要告诉交换机如何发送消息给我们的队列。交换器和队列之间的联系我们称之为绑定（binding）
            $channel->queue_bind('msgs', 'router');
            $channel->basic_consume('msgs', 'consumer', false, false, false, false, function (AMQPMessage $message)
            {

                echo "\n--------\n";
                echo $message->body;
                $message->delivery_info['channel']->basic_ack($message->delivery_info['delivery_tag']);
            });
        }
    }

    /**
     * 用户进程
     */
    public function startProcess()
    {
        parent::startProcess();

        ProcessManager::getInstance()->addProcess(MyProcess::class);

        //ProcessManager::getInstance()->addProcess(MyProcess::class,true,1);
        for ($i=0;$i<5;$i++)
        {
            ProcessManager::getInstance()->addProcess(MyAMQPTaskProcess::class,true,$i);
        }
    }

    /**
     * 可以在这验证WebSocket连接,return true代表可以握手，false代表拒绝
     * @param HttpInput $httpInput
     * @return bool
     */
    public function onWebSocketHandCheck(HttpInput $httpInput)
    {
        return true;
    }
    /**
     * ws开始连接
     * @param $server
     * @param $request
     */
    public function onSwooleWSOpen($server, $request)
    {
        //转发到控制器处理
        //$this->onSwooleWSAllMessage($server,$request->fd,'{"type":"connect"}');
    }
    public function onSwooleConnect($serv, $fd)
    {
        print_r("ok");

        parent::onSwooleConnect($serv, $fd); // TODO: Change the autogenerated stub

    }

    public function onSwooleReceive($serv, $fd, $from_id, $data, $server_port = null)
    {

        var_dump("onSwooleReceive:".$data);
        return parent::onSwooleReceive($serv, $fd, $from_id, $data, $server_port); // TODO: Change the autogenerated stub
    }


    /**
     * @return string
     */
    public function getCloseMethodName()
    {
        return 'onClose';
    }

    /**
     * @return string
     */
    public function getEventControllerName()
    {
        return 'Home/Status';
    }



    /**
     * @return string
     */
    public function getConnectMethodName()
    {
        return 'onConnect';
    }

}